import apiConfig from '@/config/relysiaApi'
import {
  updateAddress,
  updateAddressPath0,
  updatePaymail,
  updateBalance,
  updateMnemonic,
  updateWalletHistory,
} from '../redux/slices/wallet'
import { doc, getDoc, updateDoc } from 'firebase/firestore'
import { firebaseDb } from '@/firebase/init'

export const getwalletBal = async (walletid, dispatch) => {
  //wallet balance
  await apiConfig
    .get('/v1/metrics', {
      headers: {
        walletID: `${walletid}`,
      },
    })
    .then((res) => {
      let balInBsv =
        res?.data?.data?.balance / 100000000
          ? res.data.data.data.balance / 100000000
          : 0
      dispatch(updateBalance(balInBsv))
    })
    .catch((err) => {
      console.log('metrics error', err, err.response)
      if (
        err?.response?.data?.data?.msg?.includes('user utxos does not exists')
      ) {
        dispatch(updateBalance(0))
      }
    })
}

export const metricsApiWithoutBody = async () => {
  await apiConfig
    .get('/v1/metrics')
    .then((res) => {})
    .catch((err) => {
      console.log('without body', err)
    })
}

export const getwalletDetails = async (walletid, dispatch) => {
  apiConfig
    .get('/v1/address', {
      headers: {
        walletID: `${walletid}`,
      },
    })
    .then((res) => {
      dispatch(updateAddress(res.data.data.address))
      dispatch(updatePaymail(res.data.data.paymail))
    })
    .catch((err) => {
      console.log('address error', err, err.response)
      if (err?.response?.data?.data?.msg?.includes("you don't have 00000000")) {
        createwallet('default', dispatch)
      }
    })

  apiConfig
    .get('/v1/address?path=0', {
      headers: {
        walletID: `${walletid}`,
      },
    })
    .then((res) => {
      dispatch(updateAddressPath0(res.data.data.address))
    })
    .catch((err) => {
      console.log('address error', err, err.response)
    })

  //wallet balance
  getwalletBal(walletid, dispatch)

  //wallet mnemonic
  apiConfig
    .get('/v1/mnemonic', {
      headers: {
        walletID: `${walletid}`,
      },
    })
    .then((res) => {
      dispatch(updateMnemonic(res.data.data.mnemonic))
    })
    .catch((err) => {
      console.log(err)
    })

  //wallet history
  apiConfig
    .get('/v1/history', {
      headers: {
        walletID: `${walletid}`,
      },
    })
    .then((res) => {
      if (res.data.data.histories) {
        dispatch(updateWalletHistory(res.data.data.histories))
      } else {
        dispatch(updateWalletHistory([]))
      }
    })
    .catch((err) => {
      console.log(err)
    })
}

export const getWalletAddressAndPaymail = async (walletId) => {
  let obj = {
    address: null,
    paymail: null,
  }
  return await apiConfig
    .get('/v1/address?path=0', {
      headers: {
        walletID: walletId,
      },
    })
    .then((res) => {
      obj.address = res.data.data.address
      obj.paymail = res.data.data.paymail
      return obj
    })
    .catch((err) => {
      return obj
    })
}

export const createwallet = async (name, dispatch) => {
  apiConfig
    .get('/v1/createWallet', {
      headers: {
        walletTitle: `${name}`,
      },
    })
    .then((res) => {
      getwalletDetails(res.data.data.walletID, dispatch)
      return true
    })
    .catch((err) => {
      console.log('wallet error', err)
    })
}

// nft upload file

export const uploadNFTFile = async (formData, walletId) => {
  return await apiConfig
    .post('/upload', formData, {
      headers: {
        walletID: walletId,
      },
    })
    .then((res) => {
      return res.data.data
    })

    .catch((err) => {
      console.log('upload error', err)
      return false
    })
}

//minting

export const mintNFT = async (nftDetails) => {
  const { url, description, name, supply, price } = nftDetails
  const parameters = {
    name,
    protocolId: 'STAS',
    symbol: `${Math.random().toString(36).substring(2, 7)}`,
    description: description,
    image: url,
    tokenSupply: supply,
    satsPerToken: 1,
    splitable: false,
    properties: {
      legal: {
        terms:
          'Â© 2020 TAAL TECHNOLOGIES SEZC\nALL RIGHTS RESERVED. ANY USE OF THIS SOFTWARE IS SUBJECT TO TERMS AND CONDITIONS OF LICENSE. USE OF THIS SOFTWARE WITHOUT LICENSE CONSTITUTES INFRINGEMENT OF INTELLECTUAL PROPERTY. FOR LICENSE DETAILS OF THE SOFTWARE, PLEASE REFER TO: www.taal.com/stas-token-license-agreement',
        licenceId: 'BA',
      },
      issuer: {
        organisation: 'Vaionex Corp.',
        legalForm: 'Limited',
        governingLaw: 'US',
        issuerCountry: 'US',
        jurisdiction: 'US',
        email: 'info@vaionex.com',
      },
      meta: {
        schemaId: 'NFT1.0',
        website: 'openft.vercel.app',
        legal: {
          terms:
            'NFT minting showcase. The NFTs generated by users are for Openft.',
        },
        media: [
          {
            URI: 'B://6bcf4782b851ada735be89f6075e6e8415b3e72b30de1eebc58d5e0697c079f1',
            type: 'image/jpeg',
          },
        ],
      },
    },
  }

  const response = await apiConfig({
    url: '/v1/issue',
    method: 'POST',
    data: parameters,
  }).then((res) => res.data)
  console.log(response, 'mint response')

  // return {
  //   tokenId: response.data.tokenId,
  //   txId: response.data.tokenObj.issueTxid,
  // }
}
